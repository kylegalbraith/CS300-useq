# Kyle Galbraith	Compliance Level 1 - Notes
Link to repo: https://kgalb2@projects.cecs.pdx.edu/git/masseycs300-kgalb2

- To parse the additional flags that can be passed in I will need to loop through the parameters until I see a number. When I see a number I will then have to break out of that loop and read in either FIRST, FIRST LAST, or FIRST INCREMENT LAST.

- Parsing the flags will be somewhat rudimentary, except for the format flag. The format flag is going to require a little extra processing. If you see -f or --format we need to step to the next parameter to get what the format string is, making sure we update our counter as well so that we do not process the format string twice. Once we have the format string we are going to set it on the sequ object. However, we will not return the sequ object until we have tested the format string in a try catch to make sure it is valid.

- For --help or --version we will need to print either one and then exit the program with success.

- To handle going from parsing flags (aka strings) to numbers we likely do not want to loop through all of the command line arguments again so we need to know where in the array of arguments to start for the integers.

- This seems like a hacky way to do it. But we can have one while loop that goes through all of the command line args, we try to create a float out of each arg and if it throws an exception we test it for the string flags. Big problem here is that then you can have the args scattered so something like this would be processed without error 
./sequ -f 1 "%E" 10

- Loop through the command line args and try to cast the arg to a float, if it works we break out of the loop as we are now in the numerical portion of the command line.

- The equal-width flag requires us to think about when we put a zero in front and when we do not. If you do seq -w 1 10, then we need to print 01 02 03 04 05 06 07 08 09 10, not 010.

- There is a problem using the %a format option in Python because Python does support doubles and therefore the flag %a is going to throw an error. Currently researching a solution to this.

- When using -w if start = a negative and end equals a negative we need another place to the left of the decimal.

- This is bad, seq 10.0 ignores the fix point, but seq 1.00 1.0 10.0 takes the max of the number of 0's behind the decimal point. So we need to make sure that we check for this.

- The seperator command can read in the seperator differently depending on -s or --seperator. Going to need tests for that.

- --format and --separator need to output an error message when no argument is supplied for them

- I am documenting that you cannot use %a in python and thus the format you use for -f must be of type 'float' not 'double' like it is seq.

- Testing the normal operation of sequ (i.e. no flags passed in), so just FIRST, STEP, LAST
	- The sequ 0 0 test failed on 11/10/13
		Remedied on 11/10/13 by adding a check to make sure we do not take the log of 0

- Testing --help and --version
	- All tests passed succesfully

- Testing --equal-width and -w
	- The case sequ -w -1 1.1 11 is printing out to way to many places
		remedied on 11/10/13 my leftOfDecimal checks had some off by one errors
	- The case sequ -w -1 1.1 5 is actually broken in core utils seq, I handle it correctly by outputing -1.0 00.1 01.2 02.3 03.4 04.5

- Testing --format and -f
	- All tests passed succesfully, need to add code to catch invalid flags passed in. Right now I just ignore them.

- Testing --separator and -s
	- All tests passed succesfully


