# Kyle Galbraith	Compliance Level 3 & 4 - Notes
Link to repo: https://kgalb2@projects.cecs.pdx.edu/git/masseycs300-kgalb2

- Going to need to check that the one word argument for --format-word. "arabic" == integers, "floating" == floating point, "alpha" == letters, "roman" == roman numerals. The uppercase versions of alpha and roman indicate uppercase sequences. These set the type of the sequence.

- Start, end, and increment must be in the format that is consistent with the format specified in --format-word.

- Arabic arguments for start, and end can be promoted to roman numerals if --format-word=roman.

- When using the alpha format in --format-word, the increment argument must be arabic (integer). Otherwise, start and end must be in the same format as format-word.

- If no format-word is given, the format must be inferred from the end argument. 

- Various cases to look at
	-F alpha one ten
		one two three ... ten
	-F alpha 1 ten
		ERROR - start limit not in the alpha format
	-F ten
		one two three ... ten because we must infer from end=ten that 			the output should be alpha
	-F alpha one 2 ten
		one three five seven nine
	-F alpha one 2.1 ten
		ERROR - Step is not of type arabic (integer)

- Since we are using unsigned romans then the start and end limits can not be less than 0 when they are in the arabic format. Arabic numerals can be used when roman output is specified but they must be non negative. The increment, however, can be negative so that you can count backwards, again as long as the end argument is greater than 0 we will not run into a problem.

- The case where you have to determine the format for format word from the end argument has an edge case where the format you are trying to determine is alpha. Need to come up with a way to catch this case without exiting.

- NOTE: I am using a library created for Python called num_to_word that will convert a number to its word representation. This library can be found
at the following url: https://pypi.python.org/pypi/num2words/0.5.0

- CL4 syntax cat filename.txt | sequ .... > myoutput.txt

- Technically you could use --format with --format-word if the arguments are arabic or floating. However, since this is not mentioned in the spec I am making the decision to not allow this as it would increase the complexity of that code even more then it already is.

- The spec is a little unclear where it says "Each line "number" will be in the 
format specified by the "--format-word" argument, or 
inferred from the *start* or *increment* limit argument if 
the "--format-word" argument is not supplied". I am takine this to mean that you cannot do something like this: 'cat filename.txt | sequ -n one two' because you can only use alpha arguments with --format-word. Furthermore, I am assuming that when the spec says "infer from the *start* or *increment* argument when --format-word arg is not supplied" that this means that --format-word is used but no argument (i.e. floating, arabic, alpha, or roman) is specified. So this case 'cat filename.txt | sequ -n -F one two' would work and we infer the format by the increment argument.

- I was originally doing CL4 by going line by line but it has dawned on me that if you want to be able to accurately use 
-w, -p, and -P with -n then you need to read in the whole file so that you can essentially
have your end value which is (# of lines x increment - (increment - start)). If you do not do it this way
then you will end up with unexpected results when you do something like:
	'cat testfile.txt | ./sequ.py -n -P 50 20'
	
- With my current method of line by line and a 2MB file it takes about
	1.1s real

- With the revised way of reading in the whole file first it takes about
	1.2s real, therefore I am going to make the change and read the entire 
	file in first into an array. 

- Using the array method instead of line by line allows me to correctly create 
the format option needed when --format is not used. This means that --pad and --pad-spaces
will work correctly when using --number-lines.